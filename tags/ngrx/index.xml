<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ngrx on Typical personal blog</title>
    <link>https://benetis.me/tags/ngrx/index.xml</link>
    <description>Recent content in Ngrx on Typical personal blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="https://benetis.me/tags/ngrx/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Let&#39;s code: Authentication in Angular #2 - Auth service</title>
      <link>https://benetis.me/post/angular-authentication-oauth/</link>
      <pubDate>Wed, 10 May 2017 21:40:24 +0200</pubDate>
      
      <guid>https://benetis.me/post/angular-authentication-oauth/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;This is part two of &lt;strong&gt;Authentication in Angular&lt;/strong&gt; series. This one is about building authentication part to handle OAuth calls for us. You can find first post here: &lt;a href=&#34;https://benetis.me/post/angular-authentication/&#34;&gt;https://benetis.me/post/angular-authentication/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We will be using redux with our angular project to help us handle side effects. &lt;a href=&#34;https://github.com/ngrx/store&#34;&gt;https://github.com/ngrx/store&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Our setup - angular-cli 1.0 + Angular4 (Angular 4.1)&lt;/p&gt;

&lt;h3 id=&#34;aims&#34;&gt;Aims&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;After user clicks login - we need to call OAuth endpoint to get &lt;code&gt;access&lt;/code&gt; and &lt;code&gt;refresh&lt;/code&gt; tokens which we will store in local storage&lt;/li&gt;
&lt;li&gt;Show errors for user&lt;/li&gt;
&lt;li&gt;We want to store tokens in our redux store so they are easily accessible and can be added as headers to our api requests&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;login&#34;&gt;Login&lt;/h3&gt;

&lt;p&gt;Ah, the login. Grabbing the access token with your username and password.&lt;/p&gt;

&lt;h4 id=&#34;security-concerns&#34;&gt;Security concerns&lt;/h4&gt;

&lt;p&gt;We are going to save that token in local storage. Although for security purposes it should end up in cookies with &lt;code&gt;httpOnly&lt;/code&gt; and &lt;code&gt;secure&lt;/code&gt; flags. It is all because of XSS. If javascript can access token - attacker can do that also. Read more here - &lt;a href=&#34;https://auth0.com/blog/cookies-vs-tokens-definitive-guide/&#34;&gt;https://auth0.com/blog/cookies-vs-tokens-definitive-guide/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;ngrx&#34;&gt;Ngrx&lt;/h4&gt;

&lt;p&gt;Creating folder named &lt;code&gt;classes&lt;/code&gt; under &lt;code&gt;app/&lt;/code&gt; to hold &lt;code&gt;auth.reducer, auth.effects and auth.actions&lt;/code&gt;. I keep reducers and actions close to the module they belong too, although effects need to be imported in root module.&lt;/p&gt;

&lt;p&gt;We will need two actions for login. One will be dispatched when user clicks login and another after we get response from server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;LOGIN: type(&#39;[Auth] Login&#39;),
LOGIN_COMPLETE: type(&#39;[Auth] Login complete&#39;),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just a basic skeleton for now, no business logic. We will come back in a sec.&lt;/p&gt;

&lt;h4 id=&#34;login-events&#34;&gt;Login events&lt;/h4&gt;

&lt;p&gt;Upon clicking login we will dispatch event and show response to the user. If error - we will display error message from response. (&lt;code&gt;either invalid username/password&lt;/code&gt; or &lt;code&gt;too many attempts&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;So from last blog we have this &lt;code&gt;login-form.component&lt;/code&gt;. Let&amp;rsquo;s update!&lt;/p&gt;

&lt;p&gt;I like to start from models. First let&amp;rsquo;s create interface of &amp;ldquo;LoginUser&amp;rdquo; and call it exactly that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do not try to generalize User interface here. It will be hard to manage optional parameters. Just create few. Don&amp;rsquo;t be afraid to have &lt;code&gt;LoginUser&lt;/code&gt;, &lt;code&gt;RegisterUser&lt;/code&gt; and &lt;code&gt;ProfileUser&lt;/code&gt; interfaces.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export interface LoginUser {
  email: string,
  password: string,
  grant_type: &#39;password&#39;, //We set type to password since its not going to change
  client_id: 1 //Same with client_id - it is not going to change. Prevent mistakes at compile time :^)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next add variable to hold our login form variable state (info we will submit later)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public user: LoginUser = {email: &#39;&#39;, password: &#39;&#39;, client_id: 1, grant_type: &#39;password&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;onSubmit&lt;/code&gt; function which is called when user clicks &lt;code&gt;Login&lt;/code&gt;. As said previously - it dispatches event to login which we will handle later.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public onSubmit() {
  this.store.dispatch(new auth.LoginAction({...this.user}))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;auth-client-part&#34;&gt;Auth client part&lt;/h3&gt;

&lt;p&gt;We have &lt;code&gt;api-client&lt;/code&gt; which handle all api requests to backend and we could add auth routes to it also. Instead - we will create new service just for auth. Reason being - OAuth2 which we are implementing has different responses from our usual api responses (following spec) and we want to isolate them&lt;/p&gt;

&lt;p&gt;p.s similar example of what api-client is: &lt;a href=&#34;https://github.com/ESNLithuania/boarded/blob/master/src/app/services/request.service.ts&#34;&gt;https://github.com/ESNLithuania/boarded/blob/master/src/app/services/request.service.ts&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Basically a service where we wrap our requests to manage them easier.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;auth-client.ts&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public oauth(): { login: (LoginUser) =&amp;gt; Observable&amp;lt;Response&amp;gt; } {
  return {
    login: (loginUser) =&amp;gt; {
      return this
        .post(`oauth/access_token`, loginUser)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also it&amp;rsquo;s important to note that since responses are different - we need to handle errors differently. We grab error description from json response and just leave it for effect to handle.&lt;/p&gt;

&lt;p&gt;Handle error function taken from - &lt;a href=&#34;https://angular.io/docs/ts/latest/guide/server-communication.html#!#error-handling&#34;&gt;https://angular.io/docs/ts/latest/guide/server-communication.html#!#error-handling&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;private post(url: string
  , objToPost: any): Observable&amp;lt;Response&amp;gt; {

  const headers = new Headers({&#39;Content-Type&#39;: &#39;application/json&#39;});
  const options = new RequestOptions({headers: headers});

  return this.http
    .post(this.url + url, objToPost, options)
    .map(this.extractData)
    .catch(this.handleError)
}

private extractData(res: Response) {
  const body = res.json();
  return body || {};
}

private handleError(error: Response | any) {
  const errMsg = error.json().error_description
  return Observable.throw(errMsg);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our effect for doing login looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;
constructor(private actions$: Actions
   , private authClient: AuthClientService) {
 }

 @Effect()
 loginUser$: Observable&amp;lt;Action&amp;gt; = this.actions$
   .ofType(auth.ActionTypes.LOGIN)
   .map(toPayload)
   .switchMap((payload: LoginUser) =&amp;gt; {
     return this
       .authClient
       .oauth()
       .login(payload)
       .map(res =&amp;gt; new auth.LoginCompleteAction())
       .catch(err =&amp;gt; of(new auth.LoginCompleteAction(err)))
   });

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should get access token now after doing request in login form.&lt;/p&gt;

&lt;h3 id=&#34;handling-login-response&#34;&gt;Handling login response&lt;/h3&gt;

&lt;p&gt;Things to do with response:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Error -&amp;gt; Show error in login form&lt;/li&gt;
&lt;li&gt;Indicate that request is happening&lt;/li&gt;
&lt;li&gt;Successful -&amp;gt; Put token in LocalStorage &amp;amp; Redirect&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;error-handling&#34;&gt;Error handling&lt;/h4&gt;

&lt;p&gt;For errors we can create another action: &lt;code&gt;LoginCompleteErrorAction&lt;/code&gt; to pass error response to reducer and subscribe to error messages for login form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export class LoginCompleteErrorAction implements Action {
  type = ActionTypes.LOGIN_COMPLETE_WITH_ERROR;

  constructor(public payload: string) {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our &lt;code&gt;auth.reducer&lt;/code&gt; we will add few variables in state.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import * as login from &#39;./auth.actions&#39;;

export interface State {
  loginErrMsg: string;
  loginResponseAwaiting: boolean;
  loginSuccessful: boolean;
}

export const initialState: State = {
  loginErrMsg: &#39;&#39;,
  loginResponseAwaiting: false,
  loginSuccessful: false
};

export function reducer(state = initialState,
                        action: login.Actions): State {

  switch (action.type) {
    case login.ActionTypes.LOGIN: {
      return {
        ...state,
        loginResponseAwaiting: true
      }
    }
    case login.ActionTypes.LOGIN_COMPLETE_WITH_ERROR: {
      return {
        ...state,
        loginErrMsg: &amp;lt;string&amp;gt;action.payload,
        loginResponseAwaiting: false
      };
    }
    case login.ActionTypes.LOGIN_COMPLETE: {
      return {
        ...state,
        loginResponseAwaiting: false,
        loginSuccessful: true,
        loginErrMsg: &#39;&#39;
      };
    }
    default: {
      return state;
    }
  }
}

export const getLoginErrMsg = (state: State) =&amp;gt; state.loginErrMsg
export const getLoginResponseAwaiting = (state: State) =&amp;gt; state.loginResponseAwaiting
export const getLoginSuccessful = (state: State) =&amp;gt; state.loginSuccessful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;login-form.component.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form *ngIf=&amp;quot;!(loginResponseAwaiting$ | async)&amp;quot;
      fxLayout=&amp;quot;column&amp;quot;
      #loginForm=&amp;quot;ngForm&amp;quot;
      (ngSubmit)=&amp;quot;onSubmit()&amp;quot;
&amp;gt;
    &amp;lt;anv-alert [active]=&amp;quot;errMsg.length &amp;gt; 0&amp;quot;&amp;gt;{{errMsg}}&amp;lt;/anv-alert&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;email&amp;quot;
               type=&amp;quot;email&amp;quot;
               [(ngModel)]=&amp;quot;user.username&amp;quot;
               required
               validEmail
               placeholder=&amp;quot;Email&amp;quot;&amp;gt;
        &amp;lt;md-error&amp;gt;Email is invalid&amp;lt;/md-error&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;password&amp;quot;
               type=&amp;quot;password&amp;quot;
               [(ngModel)]=&amp;quot;user.password&amp;quot;
               required
               placeholder=&amp;quot;Password&amp;quot;&amp;gt;
        &amp;lt;md-error&amp;gt;Needs to be at least 8 characters&amp;lt;/md-error&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;div fxFlex=&amp;quot;33&amp;quot;
         fxFlexAlign=&amp;quot;end&amp;quot;&amp;gt;
        &amp;lt;button md-raised-button
                type=&amp;quot;submit&amp;quot;
                [disabled]=&amp;quot;!loginForm.valid&amp;quot;
        &amp;gt;Login
        &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;div *ngIf=&amp;quot;loginResponseAwaiting$ | async&amp;quot;
     fxLayoutAlign=&amp;quot;center center&amp;quot;&amp;gt;
    &amp;lt;md-spinner mode=&amp;quot;indeterminate&amp;quot;&amp;gt;&amp;lt;/md-spinner&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;login-form.component&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;@Component({
  selector: &#39;anv-login-form&#39;,
  templateUrl: &#39;./login-form.component.html&#39;,
  styleUrls: [&#39;./login-form.component.scss&#39;]
})
export class LoginFormComponent implements OnInit, OnDestroy {

  public user: LoginUser = {username: &#39;&#39;, password: &#39;&#39;, client_id: 1, grant_type: &#39;password&#39;}

  public errMsg$: Observable&amp;lt;string&amp;gt;;
  public errMsg: string = &#39;&#39;;
  public loginResponseAwaiting$: Observable&amp;lt;boolean&amp;gt;;
  public loginSuccessful$: Observable&amp;lt;boolean&amp;gt;;

  private sub: any;

  constructor(private store: Store&amp;lt;fromRoot.State&amp;gt;) {
    this.loginResponseAwaiting$ = store.select(fromRoot.getLoginResponseAwaiting)
    this.errMsg$ = store.select(fromRoot.getLoginErrMsg)

    this.sub = this.errMsg$.subscribe(_ =&amp;gt; this.errMsg)

    this.loginSuccessful$ = store.select(fromRoot.getLoginSuccessful)
  }

  ngOnInit() {
  }

  public onSubmit() {
    this.store.dispatch(new auth.LoginAction({...this.user}))
  }

  ngOnDestroy() {
    this.sub.unsubscribe()
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Response handled. If error - shows it above login form. We can adjust that to our needs in effect or reducer. We also indicate request is happening by showing &lt;code&gt;&amp;lt;md-spinner&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;saving-token&#34;&gt;Saving token&lt;/h4&gt;

&lt;p&gt;Starting with action to set access token. After we set access token we will need to update our state to have newest token + put in local storage so it can be grabbed later. State update will happen in reducer, as for LocalStorage update - it is a side effect so we will put it in effects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export interface AuthInfo {
  access_token: string,
  expires_in: number
}

private readonly tokenItem = &#39;token&#39;

@Effect()
loginComplete$: Observable&amp;lt;Action&amp;gt; = this.actions$
  .ofType(auth.ActionTypes.LOGIN_COMPLETE)
  .map(toPayload)
  .switchMap((payload: AuthInfo) =&amp;gt; {

    localStorage.setItem(this.tokenItem, JSON.stringify(payload));

    return of(new auth.SetAuthInfoAction({
      authInfo: payload,
      updated: Math.floor(Date.now() / 1000) // To know when token expires
    }))
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;There are few more things we need to do for auth to be finished. AuthGuard to protect routes, logout to clean redux state + LocalStorage items, refresh token and minor tweaks, updates.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>