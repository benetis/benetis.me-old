<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Angular on Typical personal blog</title>
    <link>https://benetis.me/tags/angular/index.xml</link>
    <description>Recent content in Angular on Typical personal blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <atom:link href="https://benetis.me/tags/angular/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Let&#39;s code: Authentication in Angular #2 - Auth service</title>
      <link>https://benetis.me/post/angular-authentication-oauth/</link>
      <pubDate>Wed, 10 May 2017 23:00:24 +0200</pubDate>
      
      <guid>https://benetis.me/post/angular-authentication-oauth/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;This is part two of &lt;strong&gt;Authentication in Angular&lt;/strong&gt; series. This one is about building authentication part to handle OAuth calls for us. You can find first post here: &lt;a href=&#34;https://benetis.me/post/angular-authentication/&#34;&gt;https://benetis.me/post/angular-authentication/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We will be using redux with our angular project to help us handle side effects. &lt;a href=&#34;https://github.com/ngrx/store&#34;&gt;https://github.com/ngrx/store&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Our setup - angular-cli 1.0 + Angular4 (Angular 4.1)&lt;/p&gt;

&lt;h3 id=&#34;aims&#34;&gt;Aims&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;After user clicks login - we need to call OAuth endpoint to get &lt;code&gt;access&lt;/code&gt; and &lt;code&gt;refresh&lt;/code&gt; tokens which we will store in local storage&lt;/li&gt;
&lt;li&gt;Show errors for user&lt;/li&gt;
&lt;li&gt;We want to store tokens in our redux store so they are easily accessible and can be added as headers to our api requests&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;login&#34;&gt;Login&lt;/h3&gt;

&lt;p&gt;Ah, the login. Grabbing the access token with your username and password.&lt;/p&gt;

&lt;h4 id=&#34;security-concerns&#34;&gt;Security concerns&lt;/h4&gt;

&lt;p&gt;We are going to save that token in local storage. Although for security purposes it should end up in cookies with &lt;code&gt;httpOnly&lt;/code&gt; and &lt;code&gt;secure&lt;/code&gt; flags. It is all because of XSS. If javascript can access token - attacker can do that also. Read more here - &lt;a href=&#34;https://auth0.com/blog/cookies-vs-tokens-definitive-guide/&#34;&gt;https://auth0.com/blog/cookies-vs-tokens-definitive-guide/&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;ngrx&#34;&gt;Ngrx&lt;/h4&gt;

&lt;p&gt;Creating folder named &lt;code&gt;classes&lt;/code&gt; under &lt;code&gt;app/&lt;/code&gt; to hold &lt;code&gt;auth.reducer, auth.effects and auth.actions&lt;/code&gt;. I keep reducers and actions close to the module they belong too, although effects need to be imported in root module.&lt;/p&gt;

&lt;p&gt;We will need two actions for login. One will be dispatched when user clicks login and another after we get response from server.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;LOGIN: type(&#39;[Auth] Login&#39;),
LOGIN_COMPLETE: type(&#39;[Auth] Login complete&#39;),
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just a basic skeleton for now, no business logic. We will come back in a sec.&lt;/p&gt;

&lt;h4 id=&#34;login-events&#34;&gt;Login events&lt;/h4&gt;

&lt;p&gt;Upon clicking login we will dispatch event and show response to the user. If error - we will display error message from response. (&lt;code&gt;either invalid username/password&lt;/code&gt; or &lt;code&gt;too many attempts&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;So from last blog we have this &lt;code&gt;login-form.component&lt;/code&gt;. Let&amp;rsquo;s update!&lt;/p&gt;

&lt;p&gt;I like to start from models. First let&amp;rsquo;s create interface of &amp;ldquo;LoginUser&amp;rdquo; and call it exactly that.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Do not try to generalize User interface here. It will be hard to manage optional parameters. Just create few. Don&amp;rsquo;t be afraid to have &lt;code&gt;LoginUser&lt;/code&gt;, &lt;code&gt;RegisterUser&lt;/code&gt; and &lt;code&gt;ProfileUser&lt;/code&gt; interfaces.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export interface LoginUser {
  email: string,
  password: string,
  grant_type: &#39;password&#39;, //We set type to password since its not going to change
  client_id: 1 //Same with client_id - it is not going to change. Prevent mistakes at compile time :^)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next add variable to hold our login form variable state (info we will submit later)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public user: LoginUser = {email: &#39;&#39;, password: &#39;&#39;, client_id: 1, grant_type: &#39;password&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;onSubmit&lt;/code&gt; function which is called when user clicks &lt;code&gt;Login&lt;/code&gt;. As said previously - it dispatches event to login which we will handle later.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public onSubmit() {
  this.store.dispatch(new auth.LoginAction({...this.user}))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;auth-client-part&#34;&gt;Auth client part&lt;/h3&gt;

&lt;p&gt;We have &lt;code&gt;api-client&lt;/code&gt; which handle all api requests to backend and we could add auth routes to it also. Instead - we will create new service just for auth. Reason being - OAuth2 which we are implementing has different responses from our usual api responses (following spec) and we want to isolate them&lt;/p&gt;

&lt;p&gt;p.s similar example of what api-client is: &lt;a href=&#34;https://github.com/ESNLithuania/boarded/blob/master/src/app/services/request.service.ts&#34;&gt;https://github.com/ESNLithuania/boarded/blob/master/src/app/services/request.service.ts&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Basically a service where we wrap our requests to manage them easier.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;auth-client.ts&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public oauth(): { login: (LoginUser) =&amp;gt; Observable&amp;lt;Response&amp;gt; } {
  return {
    login: (loginUser) =&amp;gt; {
      return this
        .post(`oauth/access_token`, loginUser)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also it&amp;rsquo;s important to note that since responses are different - we need to handle errors differently. We grab error description from json response and just leave it for effect to handle.&lt;/p&gt;

&lt;p&gt;Handle error function taken from - &lt;a href=&#34;https://angular.io/docs/ts/latest/guide/server-communication.html#!#error-handling&#34;&gt;https://angular.io/docs/ts/latest/guide/server-communication.html#!#error-handling&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;private post(url: string
  , objToPost: any): Observable&amp;lt;Response&amp;gt; {

  const headers = new Headers({&#39;Content-Type&#39;: &#39;application/json&#39;});
  const options = new RequestOptions({headers: headers});

  return this.http
    .post(this.url + url, objToPost, options)
    .map(this.extractData)
    .catch(this.handleError)
}

private extractData(res: Response) {
  const body = res.json();
  return body || {};
}

private handleError(error: Response | any) {
  const errMsg = error.json().error_description
  return Observable.throw(errMsg);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And our effect for doing login looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;
constructor(private actions$: Actions
   , private authClient: AuthClientService) {
 }

 @Effect()
 loginUser$: Observable&amp;lt;Action&amp;gt; = this.actions$
   .ofType(auth.ActionTypes.LOGIN)
   .map(toPayload)
   .switchMap((payload: LoginUser) =&amp;gt; {
     return this
       .authClient
       .oauth()
       .login(payload)
       .map(res =&amp;gt; new auth.LoginCompleteAction())
       .catch(err =&amp;gt; of(new auth.LoginCompleteAction(err)))
   });

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We should get access token now after doing request in login form.&lt;/p&gt;

&lt;h3 id=&#34;handling-login-response&#34;&gt;Handling login response&lt;/h3&gt;

&lt;p&gt;Things to do with response:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Error -&amp;gt; Show error in login form&lt;/li&gt;
&lt;li&gt;Indicate that request is happening&lt;/li&gt;
&lt;li&gt;Successful -&amp;gt; Put token in LocalStorage &amp;amp; Redirect&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;error-handling&#34;&gt;Error handling&lt;/h4&gt;

&lt;p&gt;For errors we can create another action: &lt;code&gt;LoginCompleteErrorAction&lt;/code&gt; to pass error response to reducer and subscribe to error messages for login form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export class LoginCompleteErrorAction implements Action {
  type = ActionTypes.LOGIN_COMPLETE_WITH_ERROR;

  constructor(public payload: string) {
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our &lt;code&gt;auth.reducer&lt;/code&gt; we will add few variables in state.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;import * as login from &#39;./auth.actions&#39;;

export interface State {
  loginErrMsg: string;
  loginResponseAwaiting: boolean;
  loginSuccessful: boolean;
}

export const initialState: State = {
  loginErrMsg: &#39;&#39;,
  loginResponseAwaiting: false,
  loginSuccessful: false
};

export function reducer(state = initialState,
                        action: login.Actions): State {

  switch (action.type) {
    case login.ActionTypes.LOGIN: {
      return {
        ...state,
        loginResponseAwaiting: true
      }
    }
    case login.ActionTypes.LOGIN_COMPLETE_WITH_ERROR: {
      return {
        ...state,
        loginErrMsg: &amp;lt;string&amp;gt;action.payload,
        loginResponseAwaiting: false
      };
    }
    case login.ActionTypes.LOGIN_COMPLETE: {
      return {
        ...state,
        loginResponseAwaiting: false,
        loginSuccessful: true,
        loginErrMsg: &#39;&#39;
      };
    }
    default: {
      return state;
    }
  }
}

export const getLoginErrMsg = (state: State) =&amp;gt; state.loginErrMsg
export const getLoginResponseAwaiting = (state: State) =&amp;gt; state.loginResponseAwaiting
export const getLoginSuccessful = (state: State) =&amp;gt; state.loginSuccessful
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;login-form.component.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form *ngIf=&amp;quot;!(loginResponseAwaiting$ | async)&amp;quot;
      fxLayout=&amp;quot;column&amp;quot;
      #loginForm=&amp;quot;ngForm&amp;quot;
      (ngSubmit)=&amp;quot;onSubmit()&amp;quot;
&amp;gt;
    &amp;lt;anv-alert [active]=&amp;quot;errMsg.length &amp;gt; 0&amp;quot;&amp;gt;{{errMsg}}&amp;lt;/anv-alert&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;email&amp;quot;
               type=&amp;quot;email&amp;quot;
               [(ngModel)]=&amp;quot;user.username&amp;quot;
               required
               validEmail
               placeholder=&amp;quot;Email&amp;quot;&amp;gt;
        &amp;lt;md-error&amp;gt;Email is invalid&amp;lt;/md-error&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;password&amp;quot;
               type=&amp;quot;password&amp;quot;
               [(ngModel)]=&amp;quot;user.password&amp;quot;
               required
               placeholder=&amp;quot;Password&amp;quot;&amp;gt;
        &amp;lt;md-error&amp;gt;Needs to be at least 8 characters&amp;lt;/md-error&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;div fxFlex=&amp;quot;33&amp;quot;
         fxFlexAlign=&amp;quot;end&amp;quot;&amp;gt;
        &amp;lt;button md-raised-button
                type=&amp;quot;submit&amp;quot;
                [disabled]=&amp;quot;!loginForm.valid&amp;quot;
        &amp;gt;Login
        &amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;div *ngIf=&amp;quot;loginResponseAwaiting$ | async&amp;quot;
     fxLayoutAlign=&amp;quot;center center&amp;quot;&amp;gt;
    &amp;lt;md-spinner mode=&amp;quot;indeterminate&amp;quot;&amp;gt;&amp;lt;/md-spinner&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;login-form.component&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;@Component({
  selector: &#39;anv-login-form&#39;,
  templateUrl: &#39;./login-form.component.html&#39;,
  styleUrls: [&#39;./login-form.component.scss&#39;]
})
export class LoginFormComponent implements OnInit, OnDestroy {

  public user: LoginUser = {username: &#39;&#39;, password: &#39;&#39;, client_id: 1, grant_type: &#39;password&#39;}

  public errMsg$: Observable&amp;lt;string&amp;gt;;
  public errMsg: string = &#39;&#39;;
  public loginResponseAwaiting$: Observable&amp;lt;boolean&amp;gt;;
  public loginSuccessful$: Observable&amp;lt;boolean&amp;gt;;

  private sub: any;

  constructor(private store: Store&amp;lt;fromRoot.State&amp;gt;) {
    this.loginResponseAwaiting$ = store.select(fromRoot.getLoginResponseAwaiting)
    this.errMsg$ = store.select(fromRoot.getLoginErrMsg)

    this.sub = this.errMsg$.subscribe(_ =&amp;gt; this.errMsg)

    this.loginSuccessful$ = store.select(fromRoot.getLoginSuccessful)
  }

  ngOnInit() {
  }

  public onSubmit() {
    this.store.dispatch(new auth.LoginAction({...this.user}))
  }

  ngOnDestroy() {
    this.sub.unsubscribe()
  }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/error-response.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Response handled. If error - shows it above login form. We can adjust that to our needs in effect or reducer. We also indicate request is happening by showing &lt;code&gt;&amp;lt;md-spinner&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;saving-token&#34;&gt;Saving token&lt;/h4&gt;

&lt;p&gt;Starting with action to set access token. After we set access token we will need to update our state to have newest token + put in local storage so it can be grabbed later. State update will happen in reducer, as for LocalStorage update - it is a side effect so we will put it in effects.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export interface AuthInfo {
  access_token?: string,
  expires?: number,
  expires_in?: number
}

public static readonly tokenItem = &#39;token&#39;

@Effect()
loginComplete$: Observable&amp;lt;Action&amp;gt; = this.actions$
  .ofType(auth.ActionTypes.LOGIN_COMPLETE)
  .map(toPayload)
  .switchMap((payload) =&amp;gt; {

    if (payload) {
      const authInfoUpdated: AuthInfo = {
        ...payload,
        expires: payload.expires_in + Math.floor(Date.now() / 1000)
      }
      localStorage.setItem(AuthEffects.tokenItem, JSON.stringify(authInfoUpdated));
      return of(new auth.SetAuthInfoAction(authInfoUpdated))
    } else {
      return of(new auth.LogoutAction())
    }
  })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/save-token.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;auth-guard&#34;&gt;Auth guard&lt;/h3&gt;

&lt;p&gt;Now that we have token saved in LocalStorage we can enable our AuthGuard. It will protect our routes and redirect unauthenticated user to login form.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;@Injectable()
export class AuthGuard implements CanActivate {

  private loggedIn$: Observable&amp;lt;boolean&amp;gt;;

  constructor(private store: Store&amp;lt;fromRoot.State&amp;gt;
    , private router: Router) {

    this.loggedIn$ = store.select(fromRoot.getAuthLoggedIn)

  }

  canActivate(next: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    this.store.dispatch(new auth.LoginCompleteAction(
      JSON.parse(
        localStorage.getItem(AuthEffects.tokenItem)
      )
    ))

    return this.loggedIn$.map(loggedIn =&amp;gt; {
      if (loggedIn) {
        return true;
      } else {
        this.router.navigate([&#39;/login&#39;]);
      }
    }).catch((err) =&amp;gt; {
      console.log(err)
      this.router.navigate([&#39;/login&#39;]);
      return Observable.of(false);
    }).first()
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We subscribe to get if user is loggedIn (we set this state property to true when we set AuthInfo). Before that - we dispatch an action with our token from LocalStorage. We do this - so that user from email link or bookmark can directly access our application. Everything else is self explanatory.&lt;/p&gt;

&lt;p&gt;p.s redirect url needs to be saved - I propose for you to dispatch action to save it and redirect later.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/auth-guard.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;There are few more things we need to do for auth to be finished. Logout to clean redux state + LocalStorage items, refresh token and minor tweaks, updates.&lt;/p&gt;

&lt;h3 id=&#34;feedback&#34;&gt;Feedback&lt;/h3&gt;

&lt;p&gt;If you have any suggestions - I am eagerly waiting for feedback. &lt;a href=&#34;https://benetis.me/post/contact-me/&#34;&gt;https://benetis.me/post/contact-me/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s code: CRUD in Angular with unit tests</title>
      <link>https://benetis.me/post/angular-advanced-crud/</link>
      <pubDate>Wed, 10 May 2017 23:00:24 +0200</pubDate>
      
      <guid>https://benetis.me/post/angular-advanced-crud/</guid>
      <description>

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;CRUD application we are going to implement will have some additional complexity you might expect:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;import/export data&lt;/li&gt;
&lt;li&gt;save/load chunks data&lt;/li&gt;
&lt;li&gt;lazy data processing&lt;/li&gt;
&lt;li&gt;pagination&lt;/li&gt;
&lt;li&gt;tests&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This project&amp;rsquo;s source code is in github - &lt;a href=&#34;https://github.com/benetis/angular-advanced-crud&#34;&gt;https://github.com/benetis/angular-advanced-crud&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;p.s some of code parts are not in sync going down - so I advise to also fork github repo and check code yourself&lt;/p&gt;

&lt;h2 id=&#34;requirements-task-itself&#34;&gt;Requirements &amp;amp; Task itself&lt;/h2&gt;

&lt;p&gt;Aside of the stuff we mentioned above - we obviously will be implementing CRUD operations. Our model on which are going to operate is going to be points (coordinate points &lt;code&gt;{x, y}&lt;/code&gt;).&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Input points by hand&lt;/li&gt;
&lt;li&gt;Import points from file&lt;/li&gt;
&lt;li&gt;Export points to file&lt;/li&gt;
&lt;li&gt;Clear all points&lt;/li&gt;
&lt;li&gt;Points should be paginated, pagination size can change&lt;/li&gt;
&lt;li&gt;How many squares can be formed from these squares (lazy processing)&lt;/li&gt;
&lt;li&gt;Remove loaded points&lt;/li&gt;
&lt;li&gt;Save chunk of points with specific name (if name exists - overwrite)&lt;/li&gt;
&lt;li&gt;Load chunk of points from saved list&lt;/li&gt;
&lt;li&gt;If something happens (duplicate points ignored&amp;hellip;) user needs to be informed&lt;/li&gt;
&lt;li&gt;Delete list of points&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We will be using Angular 4.1 with CLI 1.0.1&lt;/p&gt;

&lt;h2 id=&#34;planning-ui&#34;&gt;Planning UI&lt;/h2&gt;

&lt;p&gt;Quick mockup on how I imagine this will look like. Probably best starting place for any application which can be componetized.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/points-mock.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Clearly we will need a good grid/table component. I have implemented tables so many times in Angular that this time I am just gonna skip it. There is even a post on Angular table by me - [&lt;a href=&#34;https://benetis.me/post/angular-table/&#34;&gt;https://benetis.me/post/angular-table/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tabs component to switch between points and squares. (Since squares need pagination) OR just put squares table below.&lt;/p&gt;

&lt;p&gt;Action menu for actions to perform on selected rows of table&lt;/p&gt;

&lt;p&gt;Validations for inputs to add to the table. We have limits&lt;/p&gt;

&lt;p&gt;Research into square finding algorithm - but I guess we can leave that for later.&lt;/p&gt;

&lt;p&gt;Import file and upload to table can be plugged anywhere&lt;/p&gt;

&lt;p&gt;After retro - I have updated mockup with another possible solution:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/updated-mockup.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t really matter for us - we can decide this later.&lt;/p&gt;

&lt;h2 id=&#34;architecture-of-code&#34;&gt;Architecture of code&lt;/h2&gt;

&lt;p&gt;We have a mockup, requirements. Now we can look at what components, models we will need.&lt;/p&gt;

&lt;p&gt;I like to start from data since everything revolves around it. Starting from the bottom.&lt;/p&gt;

&lt;h3 id=&#34;main-types&#34;&gt;Main types&lt;/h3&gt;

&lt;p&gt;Point and Square.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;interface Point {x: number, y: number}
// Corner 1, Corner 2
interface Square {c1: Point, c2: Point, c3: Point, c4: Point}

// Self explanatory, just for planning
type ListOfPoints = Point[]
type ListOfSquares = Square[]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;modules-components-services&#34;&gt;Modules, components, services&lt;/h3&gt;

&lt;p&gt;We can live with one module - app module. No reason to complicate ourselves when task is simple&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Services:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;import/export data&lt;/li&gt;
&lt;li&gt;IO data transformer&lt;/li&gt;
&lt;li&gt;square-finder&lt;/li&gt;
&lt;li&gt;favorite-points&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Components:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;table

&lt;ul&gt;
&lt;li&gt;pagination&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;action-menu&lt;/li&gt;
&lt;li&gt;delete button&lt;/li&gt;
&lt;li&gt;save-list-button&lt;/li&gt;
&lt;li&gt;replace-list-button&lt;/li&gt;
&lt;li&gt;inputs&lt;/li&gt;
&lt;li&gt;points-table&lt;/li&gt;
&lt;li&gt;squares-table&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We might have forgotten something - but for now it seems like everything. Stuff can be added later.&lt;/p&gt;

&lt;h3 id=&#34;notorious-table&#34;&gt;Notorious table&lt;/h3&gt;

&lt;p&gt;Certainly table is one of the most popular components (everywhere?). I had a &amp;ldquo;pleasure&amp;rdquo; to create two tables (different API) in Angular and this time we will use &lt;a href=&#34;http://swimlane.github.io/ngx-datatable&#34;&gt;http://swimlane.github.io/ngx-datatable&lt;/a&gt;. We will not wrap it inside of our component just for the sake simplicity, however I certainly recommend for you to do so.&lt;/p&gt;

&lt;p&gt;To install:
&lt;code&gt;npm i @swimlane/ngx-datatable --save&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Creating skeleton for points-table using Angular CLI. Everything under &lt;code&gt;/src/app&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ng g component points-table&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Compile application. Run tests.&lt;/p&gt;

&lt;p&gt;We will need some dummy data, columns. We should think in terms of observables since we will be fetching data from this component directly.&lt;/p&gt;

&lt;p&gt;points-table.component.ts&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public points$: Observable&amp;lt;Point[]&amp;gt; = of([
    {x: 1, y: 2},
    {x: -12, y: 22},
    {x: -2222, y: 4999},
]);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;points-table.component.html&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;h2&amp;gt;Points table&amp;lt;/h2&amp;gt;
&amp;lt;ngx-datatable
  [rows]=&amp;quot;points$ | async&amp;quot;
  [columns]=&amp;quot;[{name:&#39;X&#39;},{name:&#39;Y&#39;}]&amp;quot;
  [limit]=&amp;quot;10&amp;quot;
&amp;gt;
&amp;lt;/ngx-datatable&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we can already see something:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/table-initial.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;adding-a-points&#34;&gt;Adding a points&lt;/h3&gt;

&lt;p&gt;Since we will be adding a point - we need a service to handle this for us. We want to subscribe to that service for points to be updated.&lt;/p&gt;

&lt;p&gt;Few tests TDD style and we should have basic service for getting points data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;
@Injectable()
export class PointService {

    private points = new BehaviorSubject([])
    private _points = []

    constructor() {
        this.points.subscribe(_ =&amp;gt; this._points = _)
    }

    public getPoints(): Observable&amp;lt;Point[]&amp;gt; {
        return this.points;
    }

    public addPoints(pointsToAdd): Observable&amp;lt;Point[]&amp;gt; {
        this.points.next([...this._points, ...pointsToAdd])
        return this.getPoints()
    }

}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and their tests:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;it(&#39;should return empty observable when called getPoints&#39;, done =&amp;gt; {
    service.getPoints().subscribe(p =&amp;gt; {
        expect(p).toEqual([]);
        done();
    })
})

it(&#39;should add points and return all points&#39;, done =&amp;gt; {
    const pointsToAdd = [
        {x: 1, y: 1},
        {x: 0, y: 1},
    ]

    service.addPoints(pointsToAdd).subscribe(p =&amp;gt; {
        expect(p).toEqual(pointsToAdd);
        done();
    })
})

it(&#39;should add points twice and return all points&#39;, done =&amp;gt; {
    const pointsToAdd = [
        {x: 1, y: 1},
        {x: 0, y: 1},
    ]

    service.addPoints(pointsToAdd)
    service.addPoints(pointsToAdd)

    service.getPoints().subscribe(p =&amp;gt; {
        expect(p).toEqual([...pointsToAdd, ...pointsToAdd]);
        done();
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can find these files in github - &lt;a href=&#34;https://github.com/benetis/angular-advanced-crud/blob/master/src/app/points-service.service.ts&#34;&gt;https://github.com/benetis/angular-advanced-crud/blob/master/src/app/points-service.service.ts&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Of course instead of grabbing points inside points-table we will now need to subscribe for them from service.&lt;/p&gt;

&lt;p&gt;Next - AddPoint component. Put inputs inside that component and after clicking the button - just add points to our points service.&lt;/p&gt;

&lt;p&gt;This gives us a little bit of separation since we will need to handle validation here as well.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form&amp;gt;
    &amp;lt;label&amp;gt;X
        &amp;lt;input type=&amp;quot;text&amp;quot; ngModel #x name=&amp;quot;x&amp;quot;&amp;gt;
    &amp;lt;/label&amp;gt;
    &amp;lt;label&amp;gt;Y
        &amp;lt;input type=&amp;quot;text&amp;quot; ngModel #y name=&amp;quot;y&amp;quot;&amp;gt;
    &amp;lt;/label&amp;gt;
    &amp;lt;button (click)=&amp;quot;addPoint(x.value, y.value)&amp;quot;&amp;gt;Add&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public addPoint(x: number, y: number) {
    this.pointsService.addPoints([{x, y}])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And of course validations. Limits are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;integers only&lt;/li&gt;
&lt;li&gt;min -5000, max +5000&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Being lazy - we can just install this library to provide custom validators:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;npm install ng2-validation --save&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form #addPointForm=&amp;quot;ngForm&amp;quot;&amp;gt;
    &amp;lt;label&amp;gt;X
        &amp;lt;input type=&amp;quot;text&amp;quot;
               [(ngModel)]=&amp;quot;x&amp;quot;
               #field=&amp;quot;ngModel&amp;quot;
               name=&amp;quot;x&amp;quot;
               required
               number
               [min]=&amp;quot;-5000&amp;quot;
               [max]=&amp;quot;5000&amp;quot;&amp;gt;
    &amp;lt;/label&amp;gt;
    &amp;lt;label&amp;gt;Y
        &amp;lt;input type=&amp;quot;text&amp;quot;
               [(ngModel)]=&amp;quot;y&amp;quot;
               name=&amp;quot;y&amp;quot;
               required
               number
               [min]=&amp;quot;-5000&amp;quot;
               [max]=&amp;quot;5000&amp;quot;&amp;gt;
    &amp;lt;/label&amp;gt;
    &amp;lt;button (click)=&amp;quot;addPoint(x, y)&amp;quot;&amp;gt;Add&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;p *ngIf=&amp;quot;!addPointForm.form.valid &amp;amp;&amp;amp; addPointForm.form.dirty&amp;quot;&amp;gt;
    X and Y need to be between -5000 and 5000
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/validation.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Next step is to validate if point to add doesn&amp;rsquo;t already exist in list. (No duplicates) + list cannot get bigger than 10000.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export interface PSResponse {
    message: string,
    error: boolean,
    point?: Point
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;New type will hold response from &lt;code&gt;addPoint&lt;/code&gt; to handle two conditions we defined above.&lt;/p&gt;

&lt;p&gt;Begin by updating tests in points-service. Check them here - &lt;a href=&#34;https://github.com/benetis/angular-advanced-crud/blob/master/src/app/points-service.service.spec.ts&#34;&gt;https://github.com/benetis/angular-advanced-crud/blob/master/src/app/points-service.service.spec.ts&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;As for code - we ended up with this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public addPoints(pointsToAdd: Point[]): Observable&amp;lt;PSResponse[]&amp;gt; {
        const limit = 10000
        const currentSize = this._points.length
        const union = _.differenceWith(pointsToAdd, this._points, this.isEqual)
        const xor = _.isEqual(union, this._points) ? [] : union

        const duplicates = _.intersectionWith(this._points, pointsToAdd, this.isEqual)
            .map(p =&amp;gt; ({
                error: true,
                message: &#39;duplicate&#39;,
                point: p
            }))

        const toAddSize = pointsToAdd.length
        const overLimit: boolean = (currentSize + toAddSize) &amp;gt; limit
        if (overLimit) {
            const canBeImported: number = Math.abs(limit - currentSize - toAddSize)
            this.points.next([...this._points, ...union.slice(0, canBeImported)])

            return of([
                ...duplicates,
                {error: true, message: &#39;over limit&#39;}
            ])
        } else {
            this.points.next(this._points.concat(xor))
            return of([
                ...duplicates,
            ])
        }

    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s hope to points importing and come back to table a little bit later&lt;/p&gt;

&lt;h2 id=&#34;points-importing&#34;&gt;Points importing&lt;/h2&gt;

&lt;p&gt;Check &lt;a href=&#34;https://caniuse.com/#search=file&#34;&gt;https://caniuse.com/#search=file&lt;/a&gt; to see if File API is supported. Which is good enough&lt;/p&gt;

&lt;p&gt;Create &lt;code&gt;import-gatekeeper&lt;/code&gt; component to hold our input where file will be uploaded. If file is changed - will output its contents out :)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export class ImportGatekeeperComponent implements OnInit {

    @Output()
    public fileContents: EventEmitter&amp;lt;any[]&amp;gt; = new EventEmitter();

    constructor() {
    }

    ngOnInit() {
    }

    public fileChange($event) {
        this.readFile($event.target)
    }

    private readFile(inputValue) {
        const file: File = inputValue.files[0];
        const myReader: FileReader = new FileReader();

        myReader.onloadend = e =&amp;gt; {
            this.fileContents.emit(
                myReader
                    .result
                    .split(&#39;\n&#39;)
                    .filter(_ =&amp;gt; _ !== &#39;&#39;)
                    .map(line =&amp;gt; {
                        const [x, y] = line.split(&#39; &#39;)
                        return {x: +x, y: +y}
                    })
                )
        }

        myReader.readAsText(file);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In our wrapper (app.component) connect callback function to addPoints&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;public fileUploaded(contents: any[]) {
    this.importResponses$ = this.pointService.addPoints(contents)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If file is uploaded - data is imported! All good - we get a response with what happened also! We can pass it to import gatekeeper for it to handle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/import-response.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;cosmetics&#34;&gt;Cosmetics&lt;/h3&gt;

&lt;p&gt;App is shaping up. Time to add styles, check what is redundant.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/05/cosmetics.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Little updates to UI just to have everything a little bit more organized. We can come back to it later if there is need, but this is not our focus.&lt;/p&gt;

&lt;h3 id=&#34;action-menu-and-multi-select&#34;&gt;Action menu and multi select&lt;/h3&gt;

&lt;p&gt;We want to select multiple table rows and perform actions on them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Save them as another list&lt;/li&gt;
&lt;li&gt;Delete them&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Let&#39;s code: Authentication in Angular #1 - creating login form</title>
      <link>https://benetis.me/post/angular-authentication/</link>
      <pubDate>Mon, 24 Apr 2017 19:40:24 +0200</pubDate>
      
      <guid>https://benetis.me/post/angular-authentication/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;Introduction&lt;/h3&gt;

&lt;p&gt;Login form - a gate though which user logs into application. If it is working well - you don&amp;rsquo;t notice it - if it is bad - it will always annoy you. Of course it is not only UX/UI problem - there are security implications on server side also. But we will keep these concerns beyond this post scope.&lt;/p&gt;

&lt;p&gt;We will have few blog posts on authenticating Angular application. This one will focus on login form. Before diving into login form we will outline what we in a whole for authentication&lt;/p&gt;

&lt;p&gt;The project to which we will add login form is a side project of mine. (anvilium.com)&lt;/p&gt;

&lt;p&gt;Versions: using latest angular-cli (1.0.0) with angular4(4.0.2)&lt;/p&gt;

&lt;h3 id=&#34;plan-for-authentication&#34;&gt;Plan for authentication&lt;/h3&gt;

&lt;p&gt;What we need for authentication to work:&lt;/p&gt;

&lt;p&gt;I will highlight the points which will be covered in this post.&lt;/p&gt;

&lt;p&gt;UX:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Our login page will consist of two tabs: login and registration&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;For user to register we will only ask for email and password&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;If user is not authenticated - redirect him to login page&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;It should be easy to switch between login/register tabs&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;After registering - user needs to click on activation link in email&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Technical:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If user has expired token - try refreshing it (OAuth)&lt;/li&gt;
&lt;li&gt;If user has no token or refresh token failed - redirect him to login page (OAuth)&lt;/li&gt;
&lt;li&gt;We need to limit login attempts (server only)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Password strength - at least 8 symbols&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;User should activate new account in 24 hours before it expires&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is a great post on logins written by Jeff Atwood. We will use some ideas from that post in our login form. &lt;a href=&#34;https://blog.codinghorror.com/the-god-login/&#34;&gt;https://blog.codinghorror.com/the-god-login/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;login-form-plan&#34;&gt;Login form plan&lt;/h3&gt;

&lt;p&gt;Quick sketch before I dive into actual work. (Using draw.io)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/04/anvilium-login.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Sorry for poor sketch, but ignoring that - this is how login screen should look. We will add some material look &amp;lsquo;n feel to it.&lt;/p&gt;

&lt;p&gt;Whole form is in middle of screen, centered. Register/Login are tabs which can be switched easily. Both of those tabs have two fields - &lt;em&gt;email&lt;/em&gt; and &lt;em&gt;password&lt;/em&gt;. The only difference is button bellow them which indicates action that will performed. (Login, Register). Also after user clicks register - component will indicate to user that he has to click activate link in email.&lt;/p&gt;

&lt;p&gt;Code organization considerations: we will need to display login form instead of whole application - it means route for login will need to be at app level. Will create &lt;code&gt;LoginModule&lt;/code&gt; and eagerly load it in &lt;code&gt;app.module&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;setup-and-routing&#34;&gt;Setup and routing&lt;/h3&gt;

&lt;h5 id=&#34;setup&#34;&gt;Setup&lt;/h5&gt;

&lt;p&gt;First we will create new component in our shared module folder.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cd src/app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng g module login&lt;/code&gt; Using angular-cli scaffolding we will create &lt;code&gt;LoginModule&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd login&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ng g component login&lt;/code&gt; This will create login component with all needed files and add it to &lt;code&gt;LoginModule&lt;/code&gt; declarations&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Don&amp;rsquo;t forget to include &lt;code&gt;LoginModule&lt;/code&gt; into &lt;code&gt;AppModule&lt;/code&gt; imports&lt;/p&gt;

&lt;h5 id=&#34;routing-for-app&#34;&gt;Routing for app&lt;/h5&gt;

&lt;p&gt;Currently our application is routed with navigation menu stuck in one place.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/04/route-changing.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This means we will need to add another &lt;code&gt;router-outlet&lt;/code&gt; for app itself and login page&lt;/p&gt;

&lt;p&gt;We will move our &lt;code&gt;app.component&lt;/code&gt; template to &lt;code&gt;content-main&lt;/code&gt; (new component) and instead put &lt;code&gt;router-outlet&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can read more about child route configuration here - &lt;a href=&#34;https://angular.io/docs/ts/latest/guide/router.html#!#child-route-config&#34;&gt;https://angular.io/docs/ts/latest/guide/router.html#!#child-route-config&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Moving on. Updating &lt;code&gt;app.routing&lt;/code&gt;. Moving other routes to &lt;code&gt;path: &#39;&#39;&lt;/code&gt; and adding routes as children since they are going to be routed from &lt;code&gt;content-main&lt;/code&gt; &lt;code&gt;router-outlet&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LoginModule&lt;/code&gt; routes will be kept near LoginModule and imported together with module.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export const appRoutes: Routes = [
  {
    path: &#39;&#39;,
    pathMatch: &#39;full&#39;,
    redirectTo: &#39;dashboard&#39;
  },
  { path: &#39;&#39;,
    component: ContentMainComponent,
    children: [
      {
        path: &#39;dashboard&#39;,
        loadChildren: &#39;app/+dashboard/dashboard.module#DashboardModule&#39;,
      },
      {
        path: &#39;reviews&#39;,
        loadChildren: &#39;app/+reviews/reviews.module#ReviewsModule&#39;,
      },
      {
        path: &#39;statistics&#39;,
        loadChildren: &#39;app/+statistics/statistics.module#StatisticsModule&#39;,
      },
    ]
  },
  // { path: &#39;**&#39;, component: PageNotFoundComponent }
];

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/04/login-route-without-nav.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;routing-for-login-and-registration&#34;&gt;Routing for login and registration&lt;/h5&gt;

&lt;p&gt;As discussed, we will have two routes in our login. One will be for login and another for registration. We could not include these into actual web routes - but doing so will let users to bookmark/send links to our application login/registration forms.&lt;/p&gt;

&lt;p&gt;First, dummy components for &lt;code&gt;LoginForm&lt;/code&gt; and &lt;code&gt;RegistrationForm&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In our &lt;code&gt;LoginModule&lt;/code&gt; folder:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ng g component login-form&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ng g component registration-form&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;login.component.html&lt;/code&gt; we will need to add &lt;code&gt;router-outlet&lt;/code&gt; to change our forms in this module level.&lt;/p&gt;

&lt;p&gt;Next, creating &lt;code&gt;login.routing.ts&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;export const loginRoutes: Routes = [
  {
    path: &#39;login&#39;,
    component: LoginComponent,
    children: [
      {
        path: &#39;login&#39;,
        component: LoginFormComponent,
      },
      {
        path: &#39;register&#39;,
        component: RegistrationFormComponent
      }
    ]
  },

]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and in &lt;code&gt;LoginModule&lt;/code&gt; imports we will add this line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-typescript&#34;&gt;RouterModule.forChild(loginRoutes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s see.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/04/register-login-routes.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;presentation-layer&#34;&gt;Presentation &amp;ldquo;layer&amp;rdquo;&lt;/h3&gt;

&lt;p&gt;Next up - form itself. We can use quite a lot of material components here.&lt;/p&gt;

&lt;p&gt;First step: get those tabs working. MdTabs (Material tabs) can be easily put to use. Also we will MdCard to get that nice tile looking card.&lt;/p&gt;

&lt;p&gt;Import &lt;code&gt;MdTabsModule, MdCardModule&lt;/code&gt; and you are ready to go. Grabbing example from &lt;a href=&#34;https://material.angular.io/components/component/tabs&#34;&gt;https://material.angular.io/components/component/tabs&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;we end up with this code for tabs:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;login.component.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;login-container&amp;quot;
     fxLayout=&amp;quot;column&amp;quot;
     fxLayoutAlign=&amp;quot;center center&amp;quot;&amp;gt;
    &amp;lt;md-card&amp;gt;
    &amp;lt;nav md-tab-nav-bar&amp;gt;
        &amp;lt;a md-tab-link
           routerLink=&amp;quot;/login&amp;quot;
           routerLinkActive
           [routerLinkActiveOptions]=&amp;quot;{ exact: true }&amp;quot;
           #rlaLogin=&amp;quot;routerLinkActive&amp;quot;
           [active]=&amp;quot;rlaLogin.isActive&amp;quot;&amp;gt;
            Login
        &amp;lt;/a&amp;gt;
        &amp;lt;a md-tab-link
           routerLink=&amp;quot;register&amp;quot;
           routerLinkActive
           [routerLinkActiveOptions]=&amp;quot;{ exact: true }&amp;quot;
           #rlaRegister=&amp;quot;routerLinkActive&amp;quot;
           [active]=&amp;quot;rlaRegister.isActive&amp;quot;
        &amp;gt;
            Register
        &amp;lt;/a&amp;gt;
    &amp;lt;/nav&amp;gt;
    &amp;lt;router-outlet&amp;gt;&amp;lt;/router-outlet&amp;gt;
    &amp;lt;/md-card&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Two tabs with routerLinkActive to select which one of them is active. &lt;code&gt;exact: true&lt;/code&gt; is needed to selected subroute &lt;code&gt;/login/register&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;And a little bit of flex-layout magic to center things out&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/04/md-tabs-route.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h5 id=&#34;inputs&#34;&gt;Inputs&lt;/h5&gt;

&lt;p&gt;Adding few MdInput does the magic&lt;/p&gt;

&lt;p&gt;&lt;code&gt;login-form.component.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form fxLayout=&amp;quot;column&amp;quot;&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;email&amp;quot;
               type=&amp;quot;email&amp;quot;
               [(ngModel)]=&amp;quot;email&amp;quot;
               required
               placeholder=&amp;quot;Email&amp;quot;&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;password&amp;quot;
               type=&amp;quot;password&amp;quot;
               [(ngModel)]=&amp;quot;password&amp;quot;
               required
               placeholder=&amp;quot;Password&amp;quot;&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;div fxFlex=&amp;quot;33&amp;quot; fxFlexAlign=&amp;quot;end&amp;quot;&amp;gt;
        &amp;lt;button md-raised-button&amp;gt;Login&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://benetis.me/images/2017/04/form-inputs.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We only check if field is filled but we don&amp;rsquo;t validate.&lt;/p&gt;

&lt;h5 id=&#34;validation&#34;&gt;Validation&lt;/h5&gt;

&lt;p&gt;We need to validate if email is &amp;ldquo;right&amp;rdquo; and check if passwords strength is OK. We defined requirement to be at least 8 symbols.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll skip custom validator creation - you can read on how to do that in angular docs. &lt;a href=&#34;https://angular.io/docs/ts/latest/cookbook/form-validation.html#!#custom-validation&#34;&gt;https://angular.io/docs/ts/latest/cookbook/form-validation.html#!#custom-validation&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Using material&amp;rsquo;s &lt;code&gt;&amp;lt;md-error&amp;gt;&lt;/code&gt; we simply define our validators on inputs and here we have all the stuff we need for them.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;login-form.component.html&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;form fxLayout=&amp;quot;column&amp;quot;&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;email&amp;quot;
               type=&amp;quot;email&amp;quot;
               [(ngModel)]=&amp;quot;email&amp;quot;
               required
               validEmail
               placeholder=&amp;quot;Email&amp;quot;&amp;gt;
        &amp;lt;md-error&amp;gt;Email is invalid&amp;lt;/md-error&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;md-input-container fxFlex=&amp;quot;100&amp;quot;&amp;gt;
        &amp;lt;input mdInput
               name=&amp;quot;password&amp;quot;
               type=&amp;quot;password&amp;quot;
               [(ngModel)]=&amp;quot;password&amp;quot;
               required
               minlength=&amp;quot;8&amp;quot;
               placeholder=&amp;quot;Password&amp;quot;&amp;gt;
        &amp;lt;md-error&amp;gt;Needs to be at least 8 characters&amp;lt;/md-error&amp;gt;
    &amp;lt;/md-input-container&amp;gt;
    &amp;lt;div fxFlex=&amp;quot;33&amp;quot; fxFlexAlign=&amp;quot;end&amp;quot;&amp;gt;
        &amp;lt;button md-raised-button&amp;gt;Login&amp;lt;/button&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we are done with login form.&lt;/p&gt;

&lt;h3 id=&#34;registration-form&#34;&gt;Registration form&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s simple. We just take what we have and change &amp;ldquo;Login&amp;rdquo; to &amp;ldquo;Register&amp;rdquo;. You might say duplication of code is bad, but I will argue that in this case its not worth to try to generalize. If our form gets more difficult - we can go ahead and refactor common parts.&lt;/p&gt;

&lt;p&gt;One thing to mention - we defined minimum password length on login form. We can delete that from login-form and leave it only on registration-form.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s it. We have fulfilled our requirements at the top. Until next time.&lt;/p&gt;

&lt;p&gt;You can find part #2 here - &lt;a href=&#34;https://benetis.me/post/aangular-authentication-oauth/&#34;&gt;https://benetis.me/post/angular-authentication-oauth/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;feedback&#34;&gt;Feedback&lt;/h3&gt;

&lt;p&gt;If you have any suggestions - I am eagerly waiting for feedback. &lt;a href=&#34;https://benetis.me/post/contact-me/&#34;&gt;https://benetis.me/post/contact-me/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>